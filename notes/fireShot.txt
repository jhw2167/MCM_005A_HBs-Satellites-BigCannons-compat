//Autocannon fireShot	
public void fireShot(ServerLevel level, PitchOrientedContraptionEntity entity) {
		if (this.startPos == null
			|| this.cannonMaterial == null
			|| !(this.presentBlockEntities.get(this.startPos) instanceof AbstractAutocannonBreechBlockEntity breech)
			|| !breech.canFire()) return;

		ItemStack foundProjectile = breech.extractNextInput();
		if (!(foundProjectile.getItem() instanceof AutocannonAmmoItem round)) return;
		ControlPitchContraption controller = entity.getController();

		Vec3 ejectPos = entity.toGlobalVector(Vec3.atCenterOf(this.startPos.relative(this.isHandle ? Direction.DOWN : this.initialOrientation.getOpposite())), 0);
		Vec3 centerPos = entity.toGlobalVector(Vec3.atCenterOf(BlockPos.ZERO), 0);
		ItemStack ejectStack = round.getSpentItem(foundProjectile);
		if (!ejectStack.isEmpty()) {
			//ItemStack output = breech.insertOutput(ejectStack);
			//if (!output.isEmpty()) {
			ItemEntity ejectEntity = new ItemEntity(level, ejectPos.x, ejectPos.y, ejectPos.z, ejectStack);
			Vec3 eject = ejectPos.subtract(centerPos).normalize();
			ejectEntity.setDeltaMovement(eject.scale(this.isHandle ? 0.1 : 0.5));
			ejectEntity.setPickUpDelay(20);
			level.addFreshEntity(ejectEntity);
			//}
		}

		AutocannonMaterialProperties properties = this.cannonMaterial.properties();
		AutocannonProjectilePropertiesComponent roundProperties = round.getAutocannonProperties(foundProjectile);

		boolean canFail = !CBCConfigs.server().failure.disableAllFailure.get();

		float speed = properties.baseSpeed();
		float spread = properties.baseSpread();
		boolean canSquib = roundProperties == null || roundProperties.canSquib();
		canSquib &= canFail;

		BlockPos currentPos = this.startPos.relative(this.initialOrientation);
		int barrelTravelled = 0;
		boolean squib = false;

		while (this.presentBlockEntities.get(currentPos) instanceof IAutocannonBlockEntity autocannon) {
			ItemCannonBehavior behavior = autocannon.cannonBehavior();

			if (behavior.canLoadItem(foundProjectile)) {
				++barrelTravelled;
				if (barrelTravelled <= properties.maxSpeedIncreases())
					speed += properties.speedIncreasePerBarrel();
				spread -= properties.spreadReductionPerBarrel();
				spread = Math.max(spread, 0);
				if (canSquib && barrelTravelled > properties.maxBarrelLength()) {
					StructureBlockInfo oldInfo = this.blocks.get(currentPos);
					if (oldInfo == null) return;
					behavior.tryLoadingItem(foundProjectile);
					CompoundTag tag = this.presentBlockEntities.get(currentPos).saveWithFullMetadata();
					tag.remove("x");
					tag.remove("y");
					tag.remove("z");
					StructureBlockInfo squibInfo = new StructureBlockInfo(currentPos, oldInfo.state(), tag);
					this.blocks.put(currentPos, squibInfo);
					Vec3 squibPos = entity.toGlobalVector(Vec3.atCenterOf(currentPos), 0);
					level.playSound(null, squibPos.x, squibPos.y, squibPos.z, oldInfo.state().getSoundType().getBreakSound(), SoundSource.BLOCKS, 10.0f, 0.0f);
					squib = true;
					break;
				}
				currentPos = currentPos.relative(this.initialOrientation);
			} else {
				behavior.removeItem();
				if (canFail) {
					Vec3 failurePoint = entity.toGlobalVector(Vec3.atCenterOf(currentPos), 0);
					level.explode(null, failurePoint.x, failurePoint.y, failurePoint.z, 2, Level.ExplosionInteraction.NONE);
					for (int i = 0; i < 10; ++i) {
						BlockPos pos = currentPos.relative(this.initialOrientation, i);
						this.blocks.remove(pos);
					}
					if (controller != null) controller.disassemble();
					return;
				}
			}
		}
		breech.handleFiring();
		if (squib) return;

		for (BlockPos pos : this.recoilSpringPositions) {
			if (this.presentBlockEntities.get(pos) instanceof AutocannonRecoilSpringBlockEntity spring)
				spring.handleFiring();
		}
		NetworkPlatform.sendToClientTracking(new ClientboundAnimateCannonContraptionPacket(entity), entity);

		Vec3 spawnPos = entity.toGlobalVector(Vec3.atCenterOf(currentPos.relative(this.initialOrientation)), 0);
		Vec3 vec1 = spawnPos.subtract(centerPos).normalize();
		spawnPos = spawnPos.subtract(vec1.scale(1.5));
		Vec3 particlePos = spawnPos;

		float recoilMagnitude = properties.baseRecoil();

		boolean isTracer = CBCConfigs.server().munitions.allAutocannonProjectilesAreTracers.get() || round.isTracer(foundProjectile);

		AbstractAutocannonProjectile projectile = round.getAutocannonProjectile(foundProjectile, level);
		if (projectile != null) {
			projectile.setPos(spawnPos);
			projectile.setChargePower(barrelTravelled);
			projectile.setTracer(isTracer);
			projectile.setLifetime(properties.projectileLifetime());
			projectile.shoot(vec1.x, vec1.y, vec1.z, speed, spread);
			projectile.xRotO = projectile.getXRot();
			projectile.yRotO = projectile.getYRot();

			projectile.addUntouchableEntity(entity, 1);
			Entity vehicle = entity.getVehicle();
			if (vehicle != null && CBCEntityTypes.CANNON_CARRIAGE.is(vehicle))
				projectile.addUntouchableEntity(vehicle, 1);

			level.addFreshEntity(projectile);
			if (roundProperties != null) recoilMagnitude += roundProperties.addedRecoil();
		}

		recoilMagnitude *= CBCConfigs.server().cannons.autocannonRecoilScale.getF();
		if (controller != null) controller.onRecoil(vec1.scale(-recoilMagnitude), entity);

		Vec3 particleVel = vec1.scale(1.25);
		for (ServerPlayer player : level.players()) {
			if (entity.getControllingPassenger() == player) continue;
			level.sendParticles(player, new AutocannonPlumeParticleData(1f), true, particlePos.x, particlePos.y, particlePos.z, 0, particleVel.x, particleVel.y, particleVel.z, 1.0f);
		}

		if (round.getType() == AutocannonAmmoType.MACHINE_GUN) {
			CBCUtils.playBlastLikeSoundOnServer(level, spawnPos.x, spawnPos.y, spawnPos.z, CBCSoundEvents.FIRE_MACHINE_GUN.getMainEvent(),
				SoundSource.BLOCKS, 10, 0.75f, 3f);
		} else {
			CBCUtils.playBlastLikeSoundOnServer(level, spawnPos.x, spawnPos.y, spawnPos.z, CBCSoundEvents.FIRE_AUTOCANNON.getMainEvent(),
				SoundSource.BLOCKS, 12, 1, 5f);
		}

		if (projectile != null && CBCConfigs.server().munitions.projectilesCanChunkload.get()) {
			ChunkPos cpos1 = new ChunkPos(BlockPos.containing(projectile.position()));
			RitchiesProjectileLib.queueForceLoad(level, cpos1.x, cpos1.z);
		}
	}


//BigCannon Fire Shot
@Override
	public void fireShot(ServerLevel level, PitchOrientedContraptionEntity entity) {
		BlockPos endPos = this.startPos.relative(this.initialOrientation.getOpposite());
		if (this.presentBlockEntities.get(endPos) instanceof QuickfiringBreechBlockEntity qfbreech && qfbreech.getOpenProgress() > 0)
			return;
		if (this.isDropMortar()) return;

		ControlPitchContraption controller = entity.getController();

		RandomSource rand = level.getRandom();
		BlockPos currentPos = this.startPos.immutable();
		int count = 0;
		int maxSafeCharges = this.getMaxSafeCharges();
		boolean canFail = !CBCConfigs.server().failure.disableAllFailure.get();
		float spreadSub = this.cannonMaterial.properties().spreadReductionPerBarrel();
		boolean airGapPresent = false;

		PropellantContext propelCtx = new PropellantContext();

		List<StructureBlockInfo> projectileBlocks = new ArrayList<>();
		AbstractBigCannonProjectile projectile = null;
		BlockPos assemblyPos = null;

		float minimumSpread = this.cannonMaterial.properties().minimumSpread();

		while (this.presentBlockEntities.get(currentPos) instanceof IBigCannonBlockEntity cbe) {
			BigCannonBehavior behavior = cbe.cannonBehavior();
			StructureBlockInfo containedBlockInfo = behavior.block();
			StructureBlockInfo cannonInfo = this.blocks.get(currentPos);
			if (cannonInfo == null) break;

			Block block = containedBlockInfo.state().getBlock();

			if (containedBlockInfo.state().isAir()) {
				if (count == 0)
					return;
				if (projectile == null) {
					if (projectileBlocks.isEmpty()) {
						airGapPresent = true;
						propelCtx.chargesUsed = Math.max(propelCtx.chargesUsed - 1, 0);
					} else if (canFail) { // Incomplete projectile
						this.fail(currentPos, level, entity, behavior.blockEntity, (int) propelCtx.chargesUsed);
						return;
					}
				} else {
					++propelCtx.barrelTravelled;
					if (cannonInfo.state().is(CBCTags.CBCBlockTags.REDUCES_SPREAD)) {
						propelCtx.spread = Math.max(propelCtx.spread - spreadSub, minimumSpread);
					}
					if (canFail && projectile.canSquib() && this.cannonMaterial.properties().mayGetStuck(propelCtx.chargesUsed, propelCtx.barrelTravelled) && rollSquib(rand)) {
						this.squibBlocks(currentPos, projectileBlocks);
						Vec3 squibPos = entity.toGlobalVector(Vec3.atCenterOf(currentPos.relative(this.initialOrientation)), 0);
						level.playSound(null, squibPos.x, squibPos.y, squibPos.z, cannonInfo.state().getSoundType().getBreakSound(), SoundSource.BLOCKS, 10.0f, 0.0f);
						return;
					}
				}
			} else if (block instanceof BigCannonPropellantBlock cpropel && !(block instanceof ProjectileBlock)) {
				// Initial ignition
				if (count == 0 && !cpropel.canBeIgnited(containedBlockInfo, this.initialOrientation))
					return;
				// Incompatible propellant
				if (!propelCtx.addPropellant(cpropel, containedBlockInfo, this.initialOrientation) && canFail) {
					this.fail(currentPos, level, entity, behavior.blockEntity, (int) propelCtx.chargesUsed);
					return;
				}
				this.consumeBlock(behavior, currentPos, cpropel::consumePropellant);
				if (canFail && (!cbe.blockCanHandle(cannonInfo) && rollBarrelBurst(rand)
					|| propelCtx.stress > maxSafeCharges && rollOverloadBurst(rand))) {
					this.fail(currentPos, level, entity, behavior.blockEntity, (int) propelCtx.chargesUsed);
					return;
				}
				if (airGapPresent && canFail && rollFailToIgnite(rand)) {
					Vec3 failIgnitePos = entity.toGlobalVector(Vec3.atCenterOf(currentPos.relative(this.initialOrientation)), 0);
					level.playSound(null, failIgnitePos.x, failIgnitePos.y, failIgnitePos.z, cannonInfo.state().getSoundType().getBreakSound(), SoundSource.BLOCKS, 5.0f, 0.0f);
					return;
				}
				airGapPresent = false;
			} else if (block instanceof ProjectileBlock<?> projBlock && projectile == null) {
				if (canFail && airGapPresent && rollFailToIgnite(rand)) {
					Vec3 failIgnitePos = entity.toGlobalVector(Vec3.atCenterOf(currentPos.relative(this.initialOrientation)), 0);
					level.playSound(null, failIgnitePos.x, failIgnitePos.y, failIgnitePos.z, cannonInfo.state().getSoundType().getBreakSound(), SoundSource.BLOCKS, 5.0f, 0.0f);
					return;
				}
				projectileBlocks.add(containedBlockInfo);
				if (assemblyPos == null) assemblyPos = currentPos.immutable();

				List<StructureBlockInfo> copy = ImmutableList.copyOf(projectileBlocks);
				for (ListIterator<StructureBlockInfo> projIter = projectileBlocks.listIterator(); projIter.hasNext(); ) {
					int i = projIter.nextIndex();
					StructureBlockInfo projInfo = projIter.next();
					if (projInfo.state().getBlock() instanceof ProjectileBlock<?> cproj1 && cproj1.isValidAddition(copy, projInfo, i, this.initialOrientation))
						continue;
					if (canFail)
						this.fail(currentPos, level, entity, behavior.blockEntity, (int) propelCtx.chargesUsed);
					return;
				}
				this.consumeBlock(behavior, currentPos);
				if (cannonInfo.state().is(CBCTags.CBCBlockTags.REDUCES_SPREAD)) {
					propelCtx.spread = Math.max(propelCtx.spread - spreadSub, minimumSpread);
				}
				if (projBlock.isComplete(projectileBlocks, this.initialOrientation)) {
					projectile = projBlock.getProjectile(level, projectileBlocks);
					propelCtx.chargesUsed += projectile.addedChargePower();
					if (propelCtx.chargesUsed <= 0 || canFail && propelCtx.chargesUsed < projectile.minimumChargePower()) {
						this.squibBlocks(assemblyPos, projectileBlocks);
						return;
					}
				}
				airGapPresent = false;
			} else {
				if (canFail) {
					this.fail(currentPos, level, entity, behavior.blockEntity, (int) propelCtx.chargesUsed);
					return;
				} else {
					this.consumeBlock(behavior, currentPos);
				}
			}
			currentPos = currentPos.relative(this.initialOrientation);
			BlockState cannonState = cannonInfo.state();
			if (cannonState.getBlock() instanceof BigCannonBlock cannon && cannon.getOpeningType(level, cannonState, currentPos) == BigCannonEnd.OPEN) {
				++count;
			}
		}
		if (projectile == null && !projectileBlocks.isEmpty()) {
			StructureBlockInfo info = projectileBlocks.get(0);
			if (!(info.state().getBlock() instanceof ProjectileBlock<?> projBlock)) {
				if (canFail) this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
				return;
			}
			int remaining = projBlock.getExpectedSize() - projectileBlocks.size();
			if (remaining < 1) {
				if (canFail) this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
				return;
			}
			for (int i = 0; i < remaining; ++i) {
				StructureBlockInfo additionalInfo = this.blocks.remove(currentPos);
				if (additionalInfo == null) {
					if (canFail) this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
					return;
				}
				projectileBlocks.add(additionalInfo);

				List<StructureBlockInfo> copy = ImmutableList.copyOf(projectileBlocks);
				for (ListIterator<StructureBlockInfo> projIter = projectileBlocks.listIterator(); projIter.hasNext(); ) {
					int j = projIter.nextIndex();
					StructureBlockInfo projInfo = projIter.next();
					if (projInfo.state().getBlock() instanceof ProjectileBlock<?> cproj1 && cproj1.isValidAddition(copy, projInfo, j, this.initialOrientation))
						continue;
					if (canFail) this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
					return;
				}
				currentPos = currentPos.relative(this.initialOrientation);
			}
			assemblyPos = currentPos.immutable().relative(this.initialOrientation.getOpposite());
			if (projBlock.isComplete(projectileBlocks, this.initialOrientation)) {
				projectile = projBlock.getProjectile(level, projectileBlocks);
				propelCtx.chargesUsed += projectile.addedChargePower();
				if (propelCtx.chargesUsed <= 0 || canFail && propelCtx.chargesUsed < projectile.minimumChargePower()) {
					this.squibBlocks(assemblyPos, projectileBlocks);
					return;
				}
			} else if (canFail) {
				this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
				return;
			}
		}

		Vec3 spawnPos = entity.toGlobalVector(Vec3.atCenterOf(currentPos.relative(this.initialOrientation)), 0);
		Vec3 vec = spawnPos.subtract(entity.toGlobalVector(Vec3.atCenterOf(BlockPos.ZERO), 0)).normalize();
		spawnPos = spawnPos.subtract(vec.scale(2));

		if (propelCtx.chargesUsed < minimumSpread) propelCtx.chargesUsed = minimumSpread;

		float recoilMagnitude = 0;

		if (projectile != null) {
			if (projectile instanceof IntegratedPropellantProjectile integPropel && !projectileBlocks.isEmpty()) {
				if (!propelCtx.addIntegratedPropellant(integPropel, projectileBlocks.get(0), this.initialOrientation) && canFail) {
					this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
					return;
				}
			}
			StructureBlockInfo muzzleInfo = this.blocks.get(currentPos);
			if (canFail && muzzleInfo != null && !muzzleInfo.state().isAir()) {
				this.fail(currentPos, level, entity, null, (int) propelCtx.chargesUsed);
				return;
			}
			projectile.setPos(spawnPos);
			projectile.setChargePower(propelCtx.chargesUsed);
			projectile.shoot(vec.x, vec.y, vec.z, propelCtx.chargesUsed, propelCtx.spread);
			projectile.xRotO = projectile.getXRot();
			projectile.yRotO = projectile.getYRot();

			projectile.addUntouchableEntity(entity, 1);
			Entity vehicle = entity.getVehicle();
			if (vehicle != null && CBCEntityTypes.CANNON_CARRIAGE.is(vehicle))
				projectile.addUntouchableEntity(vehicle, 1);

			level.addFreshEntity(projectile);
			recoilMagnitude += projectile.addedRecoil();
		}

		recoilMagnitude += propelCtx.recoil;
		recoilMagnitude *= CBCConfigs.server().cannons.bigCannonRecoilScale.getF();
		if (controller != null) controller.onRecoil(vec.scale(-recoilMagnitude), entity);

		this.hasFired = true;

		float soundPower = Mth.clamp(propelCtx.chargesUsed / 16f, 0, 1);
		float tone = 2 + soundPower * -8 + level.random.nextFloat() * 4f - 2f;
		float pitch = (float) Mth.clamp(Math.pow(2, tone / 12f), 0, 2);
		double shakeDistance = propelCtx.chargesUsed * CBCConfigs.server().cannons.bigCannonBlastDistanceMultiplier.getF();
		float volume = 10 + soundPower * 30;
		Vec3 plumePos = spawnPos.subtract(vec);
		propelCtx.smokeScale = Math.max(1, propelCtx.smokeScale);

		BigCannonPlumeParticleData plumeParticle = new BigCannonPlumeParticleData(propelCtx.smokeScale, propelCtx.chargesUsed, 10);
		CannonBlastWaveEffectParticleData blastEffect = new CannonBlastWaveEffectParticleData(shakeDistance,
			BuiltInRegistries.SOUND_EVENT.wrapAsHolder(CBCSoundEvents.FIRE_BIG_CANNON.getMainEvent()), SoundSource.BLOCKS,
			volume, pitch, 2, propelCtx.chargesUsed);
		Packet<?> blastWavePacket = new ClientboundLevelParticlesPacket(blastEffect, true, plumePos.x, plumePos.y, plumePos.z, 0, 0, 0, 1, 0);

		double blastDistSqr = volume * volume * 256 * 1.21;
		for (ServerPlayer player : level.players()) {
			level.sendParticles(player, plumeParticle, true, plumePos.x, plumePos.y, plumePos.z, 0, vec.x, vec.y, vec.z, 1.0f);
			if (player.distanceToSqr(plumePos.x, plumePos.y, plumePos.z) < blastDistSqr)
				player.connection.send(blastWavePacket);
		}

		if (projectile != null && CBCConfigs.server().munitions.projectilesCanChunkload.get()) {
			ChunkPos cpos1 = new ChunkPos(BlockPos.containing(projectile.position()));
			RitchiesProjectileLib.queueForceLoad(level, cpos1.x, cpos1.z);
		}
	}